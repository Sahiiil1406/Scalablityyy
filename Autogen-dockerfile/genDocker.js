const fs = require('fs');
const path = require('path');

function detectProjectType(files) {
  if (files.includes('index.html') || files.includes('webpack.config.js') || files.includes('vite.config.js')) return 'frontend';
  if (files.includes('package.json')) return 'node';
  if (files.includes('requirements.txt') || files.includes('Pipfile') || files.includes('setup.py') || files.includes('pyproject.toml')) return 'python';
  if (files.includes('pom.xml') || files.includes('build.gradle')) return 'java';
  if (files.includes('Gemfile')) return 'ruby';
  if (files.includes('composer.json')) return 'php';
  if (files.includes('go.mod')) return 'go';
  if (files.includes('Cargo.toml')) return 'rust';
  if (files.includes('CMakeLists.txt') || files.includes('Makefile')) return 'cpp';
  if (files.some(file => file.endsWith('.csproj'))) return 'csharp';
  return 'unknown';
}

function generateDockerfile(projectType) {
  switch (projectType) {
    case 'node':
      return `
# Node.js Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "start"]
      `.trim();

    case 'python':
      return `
# Python Dockerfile
FROM python:3.9
WORKDIR /app
COPY requirements.txt ./
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
      `.trim();

    case 'java':
      return `
# Java Dockerfile
FROM openjdk:11
WORKDIR /app
COPY . .
RUN javac Main.java
CMD ["java", "Main"]
      `.trim();

    case 'ruby':
      return `
# Ruby Dockerfile
FROM ruby:3.0
WORKDIR /app
COPY Gemfile Gemfile.lock ./
RUN bundle install
COPY . .
CMD ["ruby", "app.rb"]
      `.trim();

    case 'php':
      return `
# PHP Dockerfile
FROM php:8.0-apache
WORKDIR /var/www/html
COPY . .
RUN docker-php-ext-install mysqli
CMD ["apache2-foreground"]
      `.trim();

    case 'go':
      return `
# Go Dockerfile
FROM golang:1.17
WORKDIR /app
COPY . .
RUN go build -o main .
CMD ["./main"]
      `.trim();

    case 'rust':
      return `
# Rust Dockerfile
FROM rust:1.65
WORKDIR /app
COPY . .
RUN cargo build --release
CMD ["./target/release/app"]
      `.trim();

    case 'cpp':
      return `
# C++ Dockerfile
FROM gcc:11
WORKDIR /app
COPY . .
RUN make
CMD ["./app"]
      `.trim();

    case 'csharp':
      return `
# C# Dockerfile
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /app
COPY . .
RUN dotnet restore
RUN dotnet publish -c Release -o out
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=build /app/out .
CMD ["dotnet", "App.dll"]
      `.trim();

    case 'frontend':
      return `
# Frontend Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["npx", "serve", "-s", "build"]
      `.trim();

    default:
      return '# Unsupported project type. Please define a custom Dockerfile.';
  }
}

const fromPathtoArrOffiles=(dir)=>{
    const files = fs.readdirSync(dir, { withFileTypes: true });
    let filesArr = [];
    files.forEach(file => {
        if (file.isDirectory()) {
            filesArr = filesArr.concat(fromPathtoArrOffiles(path.join(dir, file.name)));
        } else {
            filesArr.push(file.name);
        }
    });
    return filesArr;
}

function autoGenerateDockerfile(repoPath) {
    console.log(`Generating Dockerfile for ${repoPath}`);
  const files = fromPathtoArrOffiles(repoPath);
  console.log(files);
  const projectType = detectProjectType(files);
    console.log(`Detected project type: ${projectType}`);

  const dockerfileContent = generateDockerfile(projectType);
  const dockerfilePath = path.join(repoPath, 'Dockerfile');

  fs.writeFileSync(dockerfilePath, dockerfileContent);
  console.log(`Dockerfile generated for ${projectType} project at ${dockerfilePath}`);
}

// Example Usage
const repoPath = './ServerHealthChecker'; // Replace with the actual path to the repository
autoGenerateDockerfile(repoPath);